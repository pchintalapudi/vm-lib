import core.collections.iterators.Iterator;
import core.collections.iterators.RandomAccessIterator;
import core.collections.ArrayLike;

interface Collection<E> {
    public def begin() -> Iterator<E>;
    public def end() -> Iterator<E>;
    public def size() -> int;
    public def empty() -> boolean {
        return this.size() == 0;
    }
    public def contains(E element) -> boolean {
        for (Iterator<E> it = this.begin(); it != this.end(); ++it) {
            if (element == it.value) {
                return true;
            }
        }
        return false;
    }

    public static def lowerBound<E extends Comparable<E>>(ArrayLike<E> view, E against) -> RandomAccessIterator<E> {
        RandomAccessIterator<E> begin = view.begin();
        RandomAccessIterator<E> end = view.end();
        if (begin == end) {
            return end;
        }
        if (begin.value >= against) {
            return begin;
        }
        RandomAccessIterator<E> finish = end - 1;
        if (finish.value < against) {
            return end;
        }
        RandomAccessIterator<E> start = begin;
        while (finish - start > 1) {
            RandomAccessIterator<E> middle = Numerics.positiveMedian(start - begin, finish - begin) + begin;
            if (middle.value < against) {
                start = middle;
            } else {
                finish = middle;
            }
        }
        return finish;
    }

    public static def upperBound<E extends Comparable<E>>(ArrayLike<E> view, E against) -> RandomAccessIterator<E> {
        RandomAccessIterator<E> begin = view.begin();
        RandomAccessIterator<E> end = view.end();
        if (begin == end) {
            return end;
        }
        if (begin.value > against) {
            return begin;
        }
        RandomAccessIterator<E> finish = end - 1;
        if (finish.value <= against) {
            return end;
        }
        RandomAccessIterator<E> start = begin;
        while (finish - start > 1) {
            RandomAccessIterator<E> middle = Numerics.positiveMedian(start - begin, finish - begin) + begin;
            if (middle.value <= against) {
                start = middle;
            } else {
                finish = middle;
            }
        }
        return finish;
    }
}