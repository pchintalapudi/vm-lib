import core.collections.Map;
import core.implicit.Hashable;
import core.implicit.CircularArray;
import core.collections.iterators.Iterator;

class ChainedHashMap<K extends Hashable, V> implements Map<K, V> {
    class HashMapEntry implements Map<K, V>.ModifiablePair {
        private final K k;
        private V v;
        package HashMapEntry prev;
        package HashMapEntry next;
        package boolean head;

        public constructor(K k, V v) {
            this.k = k;
            this.v = v;
        }

        public get key() -> K {
            return k;
        }

        public get value() -> V {
            return v;
        }

        public set value(V val) -> V {
            this.v = val;
            return val;
        }
    }

    private HashMapEntry[] hashtable;
    private int count;
    private double load_factor;
    
    private def resize(int total) -> void {
    }

    
    public def clear() -> Map<K,V> {
        for (int i = 0; i < hashtable.size(); i++) {
            hashtable[i] = null;
        }
        this.count = 0;
        return this;
    }
    public operator[](K key) -> V {
        HashMapEntry linked_list = this.hashtable[key.hash() & (this.hashtable.size() - 1)];
        if (linked_list == null) {
            return null;
        }
        do {
            if (linked_list.key == key) {
                return linked_list.value;
            }
            linked_list = linked_list.next;
        } while (!linked_list.head)
        return null;
    }
    public operator[](K key, V value) -> V {
        int index = key.hash() & (this.hashtable.size() - 1);
        HashMapEntry head = this.hashtable[index], linked_list = head;
        while (linked_list != null) {
            if (linked_list.key == key) {
                linked_list.value = value;
                return value;
            }
            linked_list = linked_list.next;
        }
        HashMapEntry new_node = new HashMapEntry(key, value);
        new_node.next = head;
        new_node.head = true;
        if (head) {
            new_node.prev = head.prev;
            head.head = false;
            head.prev = new_node;
        } else {
            new_node.prev = new_node;
            new_node.next = new_node;
        }
        this.hashtable[index] = new_node;
        return value;
    }
    public def contains(K key) -> boolean {
        HashMapEntry linked_list = this.hashtable[key.hash() & (this.hashtable.size() - 1)];
        while (linked_list != null) {
            if (linked_list.key == key) {
                return true;
            }
            linked_list = linked_list.next;
        }
        return false;
    }
    class HashMapIterator implements BidirectionalIterator<Map<K, V>.Pair> {
        private final ChainedHashMap<K, V> host;
        private int index;
        private HashMapEntry entry;

        public constructor(ChainedHashMap<K, V> host, int index, HashMapEntry entry) {
            this.host = host;
            this.index = index;
            this.entry = entry;
        }

        public get value() -> Map<K, V>.Pair {
            return entry;
        }

        public operator++() -> BidirectionalIterator<E> {
            if (!entry.next.head) {
                entry = entry.next;
                return this;
            } else while (++this.index < this.host.hashtable.size()) {
                if (this.host.hashtable[this.index]) {
                    break;
                }
            }
            if (this.index == this.host.hashtable.size()) {
                this.entry = null;
            } else {
                this.entry = this.host.hashtable[index];
            }
            return this;
        }
        public operator++(long _) -> BidirectionalIterator<E> {
            return ++new HashMapEntry(this.host, this.index, this.entry);
        }
        public operator--() -> BidirectionalIterator<E> {
            if (entry.prev) {
                entry = entry.prev;
            } else while (this.index --> 0) {
                if (this.host.hashtable[this.index]) {
                    break;
                }
            }
            if (this.index < 0) {
                this.entry = null;
            } else {
                this.entry = this.host.hashtable[index];
            }
            return this;
        }
        public operator--(long _) -> BidirectionalIterator<E>;
        public operator==(BidirectionalIterator<E> other) -> boolean;
    }
    public def begin() -> BidirectionalIterator<Map<K, V>.Pair>;
    public def end() -> BidirectionalIterator<Map<K, V>.Pair>;
    public def size() -> int {
        return count;
    }
}