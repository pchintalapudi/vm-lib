import core.implicit.Numerics;
import core.implicit.Comparable;
import core.collections.ArrayLike;
import core.collections.iterators.RandomAccessIterator;

final class Collections {
    private def Collections() {}

    public static def lowerBound<E sub Comparable<E>>(RandomAccessIterator<E> begin, RandomAccessIterator<E> end, E against) -> RandomAccessIterator<E> {
        if (begin == end) {
            return end;
        }
        if (begin.value >= against) {
            return begin;
        }
        RandomAccessIterator<E> finish = end - 1;
        if (finish.value < against) {
            return end;
        }
        RandomAccessIterator<E> start = begin;
        while (finish - start > 1) {
            RandomAccessIterator<E> middle = Numerics.positiveMedian(start - begin, finish - begin) + begin;
            if (middle.value < against) {
                start = middle;
            } else {
                finish = middle;
            }
        }
        return finish;
    }

    public static def lowerBound<E sub Comparable<E>>(ArrayLike<E> to_search, E against) -> long {
        return lowerBound(to_search.begin(), to_search.end(), against) - to_search.begin();
    }

    public static def upperBound<E sub Comparable<E>>(RandomAccessIterator<E> begin, RandomAccessIterator<E> end, E against) -> RandomAccessIterator<E> {
        if (begin == end) {
            return end;
        }
        if (begin.value > against) {
            return begin;
        }
        RandomAccessIterator<E> finish = end - 1;
        if (finish.value <= against) {
            return end;
        }
        RandomAccessIterator<E> start = begin;
        while (finish - start > 1) {
            RandomAccessIterator<E> middle = Numerics.positiveMedian(start - begin, finish - begin) + begin;
            if (middle.value <= against) {
                start = middle;
            } else {
                finish = middle;
            }
        }
        return finish;
    }

    public static def upperBound<E sub Comparable<E>>(ArrayLike<E> to_search, E against) -> long {
        return upperBound(to_search.begin(), to_search.end(), against) - to_search.begin();
    }
}